<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Timers</title>

	<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
	<!-- <script src="https://cdn.tailwindcss.com"></script> -->
	<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

		body {
			font-family: 'Inter', sans-serif;
			background-color: #f3f4f6;
			min-height: 100vh;
			margin: 0;
			padding: 0.5rem;
			transition: background-color 0.3s ease;
			/* transform: scale(0.65); */
			/* transform-origin: top center; */
		}

		.card {
			/* transform: scale(0.65); */
			/* transform-origin: top center; */
			/* margin-bottom: -2rem; */
			cursor: grab;
  			transition: transform 350ms ease;
		}

		.card.dragging {
			opacity: 0.5;
			transform: scale(1.05);
			transform-origin: top center;
  			z-index: 10;
		}

		.drag-handle {
			cursor: grab;
			touch-action: none;
			user-select: none;
		}

		.drag-handle .material-symbols-outlined {
			font-size: 1.6rem;
		}

		.drag-handle:active {
			cursor: grabbing;
		}

		.card {
			cursor: default; /* remove grab from card itself */
		}

		.main-display {
			font-size: 1.0rem !important;
		}
		.time-label, .time-value, .time-multiplier {
			font-size: 0.5rem !important;
		}

		body.dark {
			background-color: #1a202c;
		}

		.dark .card {
			background-color: #2d3748;
			border-color: #4a5568;
		}

		.dark .input-field {
			background-color: #4a5568;
			color: #e2e8f0;
			border-color: #4a5568;
		}

		.dark .input-label {
			color: #a0aec0;
		}

		.dark .btn-secondary {
			background-color: #4a5568;
			color: #e2e8f0;
		}

		.dark .icon-btn {
			color: #e2e8f0;
		}

		.dark .modal-content {
			background-color: #2d3748;
			color: #e2e8f0;
		}

		.dark .modal-content textarea {
			background-color: #4a5568;
			color: #e2e8f0;
			border-color: #4a5568;
		}

		.dark .modal-content p {
			color: #e2e8f0;
		}

		.dark .modal-content h2 {
			color: #e2e8f0;
		}

		.dark .time-label {
			color: #d1d5db !important;
		}

		.dark .time-value {
			color: #f3f4f6 !important;
		}

		.dark .progress-bar {
			background-color: #9333ea !important;
		}

		.dark .main-display {
			color: #e5e7eb !important;
		}

		.dark .card-title {
			color: #e5e7eb !important;
		}

		input[type=number]::-webkit-inner-spin-button,
		input[type=number]::-webkit-outer-spin-button {
			opacity: 1;
		}

		.hidden {
			display: none !important;
		}
	</style>
</head>

<body class="bg-gray-100">

	<!-- Message Modal -->
	<div id="messageModal" class="modal-overlay hidden z-99">
		<div class="modal-content bg-white p-6 rounded-xl shadow-xl max-w-sm w-full text-center">
			<p id="messageText" class="text-sm font-medium text-gray-800 mb-4"></p>
			<button id="closeMessageButton"
				class="bg-blue-500 text-white font-semibold text-sm py-1.5 px-4 rounded-full shadow-lg hover:bg-blue-600 transition-all">
				OK
			</button>
		</div>
	</div>

	<!-- Export/Import Data Modal -->
	<div id="dataModal" class="modal-overlay hidden">
		<div class="modal-content bg-white p-6 rounded-xl shadow-xl max-w-lg w-full relative">
			<div class="flex items-center space-x-1 absolute right-3 top-2">
				<button id="closeDataModalButton" class="delete-btn text-gray-400 hover:text-red-500 transition-colors">
					<span class="material-symbols-outlined">close</span>
				</button>
			</div>

			<h2 id="dataModalTitle" class="text-xl font-bold text-gray-800 mb-4"></h2>
			<div id="exportDataContainer" class="hidden">
				<div id="qrCodeContainer" class="hidden flex justify-center mb-4">
					<div id="qrcode"></div>
				</div>
				<textarea id="exportDataTextarea" readonly
				class="w-full h-48 p-2 border-2 border-gray-300 rounded-lg bg-gray-100 font-mono text-xs"></textarea>
				<div class="flex justify-end space-x-2 mt-4">
					<button id="toggleQRButton"
						class="bg-purple-500 text-white text-sm font-semibold py-1.5 px-4 rounded-full shadow-lg hover:bg-purple-600 transition-all">
						Show QR Code
					</button>
					<button id="copyDataButton" class="bg-blue-500 text-white text-sm font-semibold py-1.5 px-4 rounded-full shadow-lg hover:bg-blue-600 transition-all">
						Copy
					</button>
				</div>
			</div>
			<div id="importDataContainer" class="hidden">
				<textarea id="importDataTextarea" placeholder="Paste your timer data here..."
					class="w-full h-48 p-2 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors text-xs"></textarea>
				<div class="flex justify-end space-x-2 mt-4">
					<button id="importDataButton" class="bg-blue-500 text-white text-sm font-semibold py-1.5 px-4 rounded-full shadow-lg hover:bg-green-600 transition-all">
						Import
					</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Create Timer Modal -->
	<div id="createTimerModal" class="modal-overlay hidden">

		<div class="modal-content bg-white p-6 rounded-xl shadow-xl max-w-lg w-full relative">

			<div class="flex items-center space-x-1 absolute right-3 top-2">
				<button id="closeCreateModalButton" class="delete-btn text-gray-400 hover:text-red-500 transition-colors">
					<span class="material-symbols-outlined">close</span>
				</button>
			</div>

			<div class="flex items-center justify-center space-x-3 mb-4">
				<div class="flex flex-col items-center">
					<label class="input-label text-xs text-gray-500 mb-1">Days</label>
					<input type="number" inputmode="numeric" id="daysInput" placeholder="00" value="0" min="0"
						class="input-field w-16 px-2 py-1 text-center text-sm font-medium rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
				</div>
				<div class="flex flex-col items-center">
					<label class="input-label text-xs text-gray-500 mb-1">Hours</label>
					<input type="number" inputmode="numeric" id="hoursInput" placeholder="00" value="0" min="0" max="23"
						class="input-field w-16 px-2 py-1 text-center text-sm font-medium rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
				</div>
				<div class="flex flex-col items-center">
					<label class="input-label text-xs text-gray-500 mb-1">Minutes</label>
					<input type="number" inputmode="numeric" id="minutesInput" placeholder="00" value="0" min="0" max="59"
						class="input-field w-16 px-2 py-1 text-center text-sm font-medium rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
				</div>
				<div class="flex flex-col items-center">
					<label class="input-label text-xs text-gray-500 mb-1">Seconds</label>
					<input type="number" inputmode="numeric" id="secondsInput" placeholder="00" value="0" min="0" max="59"
						class="input-field w-16 px-2 py-1 text-center text-sm font-medium rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
				</div>
			</div>

			<div class="flex items-center justify-center space-x-3">
				<div class="flex items-center mt-5">
					<button id="startButton"
						class="bg-blue-500 text-white text-sm font-semibold py-2 px-6 rounded-full shadow-lg hover:bg-blue-600 transition-all transform hover:scale-105 active:scale-95 flex items-center space-x-2">
						<span class="material-symbols-outlined">play_circle</span>
						<span>Start Timer</span>
					</button>
				</div>
				<div class="flex flex-col items-center">
					<label class="input-label text-xs text-gray-500 mb-1">Speed</label>
					<select id="multiplierSelect"
						class="input-field rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm py-1 px-3">
						<option value="1">1x</option>
						<option value="1.5">1.5x</option>
						<option value="2">2x</option>
						<option value="3">3x</option>
						<option value="4" selected>4x</option>
						<option value="5">5x</option>
						<option value="6">6x</option>
					</select>
				</div>
			</div>
		</div>
	</div>

	<div class="max-w-2xl mx-auto space-y-1">

		<!-- Running Timers Container -->
		<div id="timersContainer" class=" space-y-1"></div>

		<!-- Controls -->
		<div class="flex justify-center space-x-4">
			<button id="exportButton"
				class="btn-secondary bg-gray-500 text-white text-sm font-semibold py-2 px-2 rounded-full shadow-lg hover:bg-gray-600 transition-all transform hover:scale-105 active:scale-95">
				Export
			</button>
			<button id="importButton"
				class="btn-secondary bg-gray-500 text-white text-sm font-semibold py-2 px-2 rounded-full shadow-lg hover:bg-gray-600 transition-all transform hover:scale-105 active:scale-95">
				Import
			</button>
			<button id="formatToggleButton"
				class="btn-secondary bg-gray-500 text-white text-sm font-semibold py-2 px-2 rounded-full shadow-lg hover:bg-gray-600 transition-all transform hover:scale-105 active:scale-95">
				<span class="material-symbols-outlined">schedule</span>
			</button>
			<button id="themeToggleButton"
				class="btn-secondary bg-gray-500 text-white text-sm font-semibold py-2 px-2 rounded-full shadow-lg hover:bg-gray-600 transition-all transform hover:scale-105 active:scale-95">
				<span class="material-symbols-outlined">dark_mode</span>
			</button>
			<button id="openCreateButton"
				class="bg-blue-500 text-white text-sm font-semibold py-2 px-6 rounded-full shadow-lg hover:bg-blue-600 transition-all transform hover:scale-105 active:scale-95">
				+
			</button>
		</div>
	</div>

	<script>
		let timers = [];
		let globalInterval = null;
		let nextTimerId = 1;
		let timeFormat = 'dhms';

		const timeFormats = ['dhms', 'dhmsLong', 'clock', 'clockD'];

		// Get all DOM elements
		const messageModal = document.getElementById('messageModal');
		const messageText = document.getElementById('messageText');
		const closeMessageButton = document.getElementById('closeMessageButton');
		const themeToggleButton = document.getElementById('themeToggleButton');
		const formatToggleButton = document.getElementById('formatToggleButton');
		const dataModal = document.getElementById('dataModal');
		const dataModalTitle = document.getElementById('dataModalTitle');
		const exportDataContainer = document.getElementById('exportDataContainer');
		const importDataContainer = document.getElementById('importDataContainer');
		const copyDataButton = document.getElementById('copyDataButton');
		const importDataButton = document.getElementById('importDataButton');
		const importDataTextarea = document.getElementById('importDataTextarea');
		const timersContainer = document.getElementById('timersContainer');
		const startButton = document.getElementById('startButton');
		const exportButton = document.getElementById('exportButton');
		const importButton = document.getElementById('importButton');
		const openCreateButton = document.getElementById('openCreateButton');
		const closeCreateModalButton = document.getElementById('closeCreateModalButton');
		const createTimerModal = document.getElementById('createTimerModal');

		const daysInput = document.getElementById('daysInput');

		const inputs = [
			document.getElementById('daysInput'),
			document.getElementById('hoursInput'),
			document.getElementById('minutesInput'),
			document.getElementById('secondsInput')
		];

		inputs.forEach(input => {
			input.addEventListener('focus', () => input.select());
		});


		const applyTheme = (isDark) => {
			if (isDark) {
				document.body.classList.add('dark');
				themeToggleButton.innerHTML = '<span class="material-symbols-outlined">light_mode</span>';
			} else {
				document.body.classList.remove('dark');
				themeToggleButton.innerHTML = '<span class="material-symbols-outlined">dark_mode</span>';
			}
		};

		openCreateButton.addEventListener('click', () => {
			createTimerModal.classList.remove('hidden');
			daysInput.select();
		});

		closeCreateModalButton.addEventListener('click', () => {
			createTimerModal.classList.add('hidden');
		});

		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape') {
				if (!createTimerModal.classList.contains('hidden')) {
					createTimerModal.classList.add('hidden');
				} else if (!dataModal.classList.contains('hidden')) {
					dataModal.classList.add('hidden');
				} else if (!messageModal.classList.contains('hidden')) {
					messageModal.classList.add('hidden');
				}
			}
		});

		themeToggleButton.addEventListener('click', () => {
			const isDark = document.body.classList.contains('dark');
			localStorage.setItem('theme', isDark ? 'light' : 'dark');
			applyTheme(!isDark);
		});

		formatToggleButton.addEventListener('click', () => {
			let currentIndex = timeFormats.indexOf(timeFormat);
			let nextIndex = (currentIndex + 1) % timeFormats.length;
			timeFormat = timeFormats[nextIndex];

			localStorage.setItem('timeFormat', timeFormat);

			formatTimersDo()

			updateTimers();
		});

		function formatTimersDo() {
			const timerElements = document.querySelectorAll('.timer-start-end');
			const timerElementMultiplier = document.querySelectorAll('.time-multiplier');

			if (timeFormat === 'dhms' || timeFormat === 'dhmsLong') {
				timerElements.forEach(el => el.classList.remove('hidden'));
			} else {
				timerElements.forEach(el => el.classList.add('hidden'));
			}

			if (timeFormat === 'dhmsLong') {
				timerElementMultiplier.forEach(el => el.classList.add('hidden'));
			} else {
				timerElementMultiplier.forEach(el => el.classList.remove('hidden'));
			}
		}

		function showMessage(text) {
			messageText.textContent = text;
			messageModal.classList.remove('hidden');
		}

		closeMessageButton.addEventListener('click', () => {
			messageModal.classList.add('hidden');
		});

		document.getElementById('closeDataModalButton').addEventListener('click', () => {
			dataModal.classList.add('hidden');
		});

		const formatTime = (seconds) => {
			if (seconds < 0) seconds = 0;
			const d = Math.floor(seconds / (3600 * 24));
			const h = Math.floor((seconds % (3600 * 24)) / 3600);
			const m = Math.floor((seconds % 3600) / 60);
			const s = Math.floor(seconds % 60);
			return { d, h, m, s };
		};

		const formatTimeString = (seconds) => {
			const time = formatTime(seconds);

			if (timeFormat === 'clock') {
				formattedTimeString = `${String(time.d*24+time.h).padStart(2, '0')}:${String(time.m).padStart(2, '0')}:${String(time.s).padStart(2, '0')}`;
			} else if (timeFormat === 'clockD') {
				formattedTimeString = `${String(time.d).padStart(2, '0')}d \u00A0\u00A0\u00A0\u00A0\u00A0 ${String(time.h).padStart(2, '0')}:${String(time.m).padStart(2, '0')}:${String(time.s).padStart(2, '0')}`;
			} else {
				formattedTimeString = `${String(time.d).padStart(2, '0')}d ${String(time.h).padStart(2, '0')}h ${String(time.m).padStart(2, '0')}m ${String(time.s).padStart(2, '0')}s`;
				// if (timeFormat === 'dhmsLong') {
				// 	formattedTimeString = ` ${formattedTimeString} (no speed)`;
				// }
			}
			return formattedTimeString;
		};

		const formatDateTime = (timestamp) => {
			const date = new Date(timestamp);
			return date.toLocaleString('en-US', {
				month: 'short',
				day: 'numeric',
				hour: 'numeric',
				minute: '2-digit',
				hour12: true
			});
		};

		const createTimerCard = (timer) => {
			const card = document.createElement('div');
			card.className = 'card bg-white p-2 rounded-l shadow-lg border border-gray-200';
			card.id = `timer-${timer.id}`;
			card.draggable = true;

			const now = Date.now();
			const timeLeft = Math.max(0, Math.floor((timer.endTime - now) / 1000));
			const percentage = timer.duration > 0 ? 100 - (timeLeft / timer.duration) * 100 : 0;

			// drag handle, implement later
			// <span class="time-value text-xs font-medium text-gray-700">${formatDateTime(timer.startTime)}</span>
			// <span class="time-label text-xs text-gray-500">-</span>

			card.innerHTML = `
				<div class="flex items-start">
					<div class="drag-handle flex items-center pr-2 pt-3">
						<span class="material-symbols-outlined text-gray-400">drag_indicator</span>
					</div>
					<div class="flex-1">
						<div class="flex items-center justify-center mb-1 relative">
							<div class="timer-start-end flex items-center space-x-1 mb-1">
								<span class="time-label text-xs text-gray-500">Complete: </span>
								<span class="time-value text-xs font-medium text-gray-700">${formatDateTime(timer.endTime)}</span>
								<span class="time-multiplier text-xs text-purple-600 font-semibold">(${timer.multiplier}x speed)</span>
							</div>
							<div class="flex items-center space-x-1 absolute right-0">
								<button class="edit-btn text-gray-400 hover:text-blue-500 transition-colors" data-timer-id="${timer.id}">
									<span class="material-symbols-outlined">content_copy</span>
								</button>
								<button class="delete-btn text-gray-400 hover:text-red-500 transition-colors" data-timer-id="${timer.id}">
									<span class="material-symbols-outlined">close</span>
								</button>
							</div>
						</div>
						<div class="text-center mb-2">
							<div class="main-display text-l font-bold text-gray-800" id="display-${timer.id}">${formatTimeString(timeLeft)}</div>
						</div>
						<div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden shadow-inner">
							<div id="progress-${timer.id}" class="progress-bar bg-blue-500 h-full rounded-full transition-all duration-1000 ease-linear" style="width: ${percentage}%;"></div>
						</div>
					</div>
				</div>
			`;

			const editBtn = card.querySelector('.edit-btn');
			editBtn.addEventListener('click', () => editTimer(timer.id));

			const deleteBtn = card.querySelector('.delete-btn');
			deleteBtn.addEventListener('click', () => deleteTimer(timer.id));

			return card;
		};

		const updateTimers = () => {
			const now = Date.now();
			let hasActiveTimers = false;

			timers.forEach(timer => {
				const timeLeft = Math.max(0, Math.floor((timer.endTime - now) / 1000));
				const percentage = timer.duration > 0 ? 100 - (timeLeft / timer.duration) * 100 : 0;

				const displayEl = document.getElementById(`display-${timer.id}`);
				const progressEl = document.getElementById(`progress-${timer.id}`);

				if (displayEl && progressEl) {
					displayEl.textContent = formatTimeString((timeFormat === 'dhmsLong') ? timeLeft * timer.multiplier : timeLeft);
					progressEl.style.width = `${percentage}%`;

					if (timeLeft > 0) {
						hasActiveTimers = true;
					}
				}
			});

			timers = timers.filter(timer => {
				const timeLeft = Math.max(0, Math.floor((timer.endTime - now) / 1000));
				if (timeLeft === 0) {
					const card = document.getElementById(`timer-${timer.id}`);
					if (card) {
						card.remove();
					}
					return false;
				}
				return true;
			});

			if (!hasActiveTimers && globalInterval) {
				clearInterval(globalInterval);
				globalInterval = null;
			}
		};

		const startGlobalInterval = () => {
			if (!globalInterval) {
				globalInterval = setInterval(updateTimers, 1000);
			}
		};

		const editTimer = (timerId) => {
			const timer = timers.find(t => t.id === timerId);
			if (!timer) return;

			const now = Date.now();
			const timeLeft = Math.max(0, Math.floor((timer.endTime - now) * timer.multiplier / 1000));
			const time = formatTime(timeLeft);

			createTimerModal.classList.remove('hidden');

			daysInput.value = time.d;
			document.getElementById('hoursInput').value = time.h;
			document.getElementById('minutesInput').value = time.m;
			document.getElementById('secondsInput').value = time.s;
			document.getElementById('multiplierSelect').value = timer.multiplier;

			daysInput.select();
		};

		startButton.addEventListener('click', () => {
			const days = parseInt(daysInput.value) || 0;
			const hours = parseInt(document.getElementById('hoursInput').value) || 0;
			const minutes = parseInt(document.getElementById('minutesInput').value) || 0;
			const seconds = parseInt(document.getElementById('secondsInput').value) || 0;
			const multiplier = parseFloat(document.getElementById('multiplierSelect').value);

			const totalSeconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds;

			if (totalSeconds <= 0) {
				showMessage('Please set a duration for the timer.');
				return;
			}

			const actualDuration = Math.floor(totalSeconds / multiplier);
			const startTime = Date.now();
			const endTime = startTime + (actualDuration * 1000);

			//preserving nextTimerID after load is important so deleted id's are not re-used
			const timer = {
				startTime,
				endTime,
				duration: actualDuration,
				multiplier
			};

			timers.push(timer);

			saveState(saveRaw=true);

			initCards();

			createTimerModal.classList.add('hidden');
		});

		const deleteTimer = (timerId) => {
			timers = timers.filter(t => t.id !== timerId);
			//we could splice out the timer from the js Array, but saveState is handling that already...
			const card = document.getElementById(`timer-${timerId}`);
			if (card) {
				card.remove();
			}
			saveState();
		};

		const devTimerIds = () => {
			var saveTimers;

			saveTimers = [...document.querySelectorAll('.card')].map(card => {
				return card.id;
			});

			console.log("devTimerIds", saveTimers);
		}

		const saveState = (saveRaw=false) => {
			var saveTimers;

			if (!saveRaw) {
				// Save timer order based on DOM order, excluding IDs
				saveTimers = [...document.querySelectorAll('.card')].map(card => {
					const timerId = parseInt(card.id.replace('timer-', ''));
					const timer = timers.find(t => t.id === timerId);
					if (!timer) return null;

					// Return timer without the id
					const { id, ...timerWithoutId } = timer;
					return timerWithoutId;
				}).filter(Boolean);
			} else {
				saveTimers = timers.map(({ id, ...timer }) => timer);
			}

			localStorage.setItem('timerState', JSON.stringify({ timers: saveTimers }));
		};

		const loadState = () => {
			const storedState = localStorage.getItem('timerState');
			if (storedState) {
				try {
					const data = JSON.parse(storedState);
					// Renumber timers from 1 to n
					const loadedTimers = (data.timers || []).map((timer, index) => ({
						...timer,
						id: index + 1
					}));
					nextTimerId = loadedTimers.length + 1;
					return loadedTimers;
				} catch (e) {
					console.error("Failed to parse localStorage data:", e);
				}
			}
			return [];
		};

		importButton.addEventListener('click', () => {
			dataModalTitle.textContent = 'Import Timers';
			exportDataContainer.classList.add('hidden');
			importDataContainer.classList.remove('hidden');
			importDataTextarea.value = '';
			dataModal.classList.remove('hidden');
		});

		copyDataButton.addEventListener('click', () => {
			const exportTextarea = document.getElementById('exportDataTextarea');
			exportTextarea.select();
			document.execCommand('copy');
			dataModal.classList.add('hidden');
			showMessage('Copied to clipboard!');
		});

		function initCards() {
			timers = loadState();

			if (timers.length > 0) {
				timersContainer.innerHTML = '';

				nextTimerId = 0;
				timers.forEach(timer => {
					const card = createTimerCard(timer);
					timersContainer.appendChild(card);
				});
				startGlobalInterval();

				setInterval(() => {
					formatTimersDo();
				}, 50);

				startGlobalInterval();
			}
		}

		window.addEventListener('load', () => {
			/*Apple the same classes for all modals*/
			const modalOverlayClasses = [
				'fixed',
				'inset-0',
				'z-50',
				'flex',
				'items-start',
				'p-10',
				'justify-center',
				'bg-black/70',
				'backdrop-blur-md',
				'hidden'
			];
			// const modalContentClasses = "modal-content bg-white rounded-xl shadow-xl p-6 max-w-lg w-full relative";

			document.querySelectorAll('.modal-overlay').forEach(div => {
				div.classList.add(...modalOverlayClasses);
			});

			initCards();

			const savedTheme = localStorage.getItem('theme') || 'dark';  // default to 'dark'
			applyTheme(savedTheme === 'dark');

			const savedFormat = localStorage.getItem('timeFormat');
			if (savedFormat) {
				timeFormat = savedFormat;
			}
		});
	</script>

	<script>/*compression and QR code*/
		// Add after the DOM element declarations
		const toggleQRButton = document.getElementById('toggleQRButton');
		const qrCodeContainer = document.getElementById('qrCodeContainer');

		function compressData(data) {
			const jsonStr = JSON.stringify(data);
			const compressed = pako.deflate(jsonStr, { level: 9 });
			return btoa(String.fromCharCode.apply(null, compressed));
		}

		function decompressData(compressedStr) {
			try {
				const compressed = Uint8Array.from(atob(compressedStr), c => c.charCodeAt(0));
				const decompressed = pako.inflate(compressed, { to: 'string' });
				return JSON.parse(decompressed);
			} catch (e) {
				return null;
			}
		}

		toggleQRButton.addEventListener('click', () => {
			if (qrCodeContainer.classList.contains('hidden')) {
				qrCodeContainer.classList.remove('hidden');
				qrCodeContainer.innerHTML = '<div id="qrcode"></div>';

				const compressed = compressData({ timers });

				// Show compressed string in textarea while QR is visible
				document.getElementById('exportDataTextarea').value = compressed;

				new QRCode(document.getElementById("qrcode"), {
					text: compressed,
					width: 256,
					height: 256
				});

				toggleQRButton.textContent = 'Hide QR Code';
			} else {
				qrCodeContainer.classList.add('hidden');

				// Restore raw JSON when hiding QR
				const timersWithoutIds = timers.map(({ id, ...timer }) => timer);
				document.getElementById('exportDataTextarea').value = JSON.stringify({ "timers": timersWithoutIds }, null, 2);

				toggleQRButton.textContent = 'Show QR Code';
			}
		});

		// Update export button
		exportButton.addEventListener('click', () => {
			saveState();

			dataModalTitle.textContent = 'Export Timers';
			exportDataContainer.classList.remove('hidden');
			importDataContainer.classList.add('hidden');

			// Always show raw JSON in textarea
			const timersWithoutIds = timers.map(({ id, ...timer }) => timer);
			document.getElementById('exportDataTextarea').value = JSON.stringify({ "timers": timersWithoutIds }, null, 2);

			qrCodeContainer.classList.add('hidden');
			toggleQRButton.textContent = 'Show QR Code';

			dataModal.classList.remove('hidden');
		});

		// Update import button handler
		importDataButton.addEventListener('click', () => {
			const text = importDataTextarea.value.trim();
			if (text) {
				try {
					let data;

					// Try to parse as raw JSON first
					try {
						data = JSON.parse(text);
					} catch (e) {
						// If that fails, try to decompress
						data = decompressData(text);
					}

					if (data && data.timers && Array.isArray(data.timers)) {
						timers = data.timers;

						//save the imported data
						saveState(saveRaw=true)

						initCards();

						dataModal.classList.add('hidden');
						//todo add an optional timer fade to showMessage
						//showMessage('Timers imported successfully!', 5000);
					} else {
						showMessage('Invalid timer data format.');
					}
				} catch (e) {
					showMessage('Invalid format. Please paste valid JSON or compressed data.');
				}
			} else {
				showMessage('Please paste valid timer data.');
			}
		});
	</script>

	<script>/*Drag animations*/
		const container = document.getElementById("timersContainer");
		let draggedElement = null;
		let touchStartY = 0;
		let placeholder = null;

		function handleDragMove(clientY) {
			const dragging = document.querySelector(".dragging");
			if (!dragging) return;

			const cards = [...container.querySelectorAll(".card:not(.dragging)")];

			// Record where everything is BEFORE moving anything
			const startRects = new Map(cards.map(el => [el, el.getBoundingClientRect()]));

			// Reinsert dragged card in new position
			const afterElement = getDragAfterElement(container, clientY);
			if (afterElement == null) {
				container.appendChild(dragging);
			} else {
				container.insertBefore(dragging, afterElement);
			}

			// Now measure AFTER moving
			const endRects = new Map(cards.map(el => [el, el.getBoundingClientRect()]));

			// Apply FLIP animation
			cards.forEach(el => {
				const start = startRects.get(el);
				const end = endRects.get(el);
				const deltaY = start.top - end.top;
				if (deltaY !== 0) {
					el.style.transform = `translateY(${deltaY}px)`; // invert
					el.style.transition = "none";
					// Force a reflow so browser registers this starting position
					el.getBoundingClientRect();
					el.style.transition = "transform 350ms ease";
					el.style.transform = ""; // play
				}
			});
		}

		container.addEventListener("dragover", e => {
			e.preventDefault();
			handleDragMove(e.clientY);
		});

		container.addEventListener("touchmove", e => {
			if (!draggedElement) return;
			const touch = e.touches[0];
			handleDragMove(touch.clientY);
		}, { passive: true });

		container.addEventListener("dragstart", e => {
			if (!e.target.classList.contains("card")) return;
			e.target.classList.add("dragging");
		});

		container.addEventListener("touchstart", e => {
			const handle = e.target.closest('.drag-handle');
			if (!handle) return;

			draggedElement = handle.closest('.card');
			touchStartY = e.touches[0].clientY;

			draggedElement.classList.add('dragging');

			// Create placeholder
			placeholder = draggedElement.cloneNode(true);
			placeholder.style.opacity = '0.3';
			placeholder.style.pointerEvents = 'none';
		}, { passive: true });

		container.addEventListener("dragend", e => {
			if (!e.target.classList.contains("card")) return;
			e.target.classList.remove("dragging");
			saveState(); // Save the new order
		});

		container.addEventListener("touchend", e => {
			if (!draggedElement) return;

			draggedElement.classList.remove('dragging');
			if (placeholder && placeholder.parentNode) {
				placeholder.remove();
			}

			draggedElement = null;
			placeholder = null;

			saveState(); // Save the new order
		}, { passive: true });

		function getDragAfterElement(container, y) {
			const GAP_FACTOR = 0.01; // adjust for sensitivity
			const elements = [...container.querySelectorAll(".card:not(.dragging)")];
			return elements.reduce((closest, el) => {
				const box = el.getBoundingClientRect();
				const offset = y - box.top - box.height * GAP_FACTOR;
				return (offset < 0 && offset > closest.offset)
					? { offset, element: el }
					: closest;
			}, { offset: Number.NEGATIVE_INFINITY }).element;
		}
	</script>
</body>

</html>
